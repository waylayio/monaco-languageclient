"""
This type stub file was generated by pyright.
"""

import pandas as pd
from typing import Any, Callable, Iterator, List, Optional, Sequence, Tuple
from datetime import datetime
from contextlib import contextmanager
from .model import CSVReader, MeasurementIterator, MeasurementValue, Metric, Resource, SeriesIterator, SeriesSettings, WaylayETLSeriesImport

"""Reader utilities for a etl-formatted file."""
@contextmanager
def read_etl_import_as_stream(etl_import: WaylayETLSeriesImport) -> Iterator[CSVReader]:
    """Iterate of the content of stored etl file (gzipped csv file)."""
    ...

@contextmanager
def read_etl_import(etl_import: WaylayETLSeriesImport) -> Iterator[SeriesIterator]:
    """Create a Series Iterator from a stored etl file (gzipped csv file)."""
    ...

def dataframe_from_iterator(series_iterator: SeriesIterator) -> pd.DataFrame:
    """Create a Pandas dataframe from a SeriesIterator."""
    ...

def list_resources(settings: SeriesSettings, series_iterator: SeriesIterator) -> List[Resource]:
    """Get a `Resource` list that describes the resources an metrics found in the given series collection.

    Uses the `settings.resources` and `settings.metrics` as a data dictionary to enhance the
    _resource_ and _metric_ descriptions found in the series.
    """
    class ResourceDict(dict):
        ...
    
    

DONE = ...
NEXT = ...
SeriesRow = Tuple[Any]
class SeriesCursor:
    """A look-ahead polling cursor on a etl-formatted csv stream, splitting the series."""
    def __init__(self, reader, metrics: Optional[Sequence[Metric]] = ..., on_close: Optional[Callable] = ...) -> None:
        """Create a Series reader.

        The reader should provide an iterator of string-formatted
        (timestamp, resource, metric, value) tuples.
        """
        ...
    
    def iter_rows(self) -> MeasurementIterator:
        """Get an iterator of the series at the current cursor position.

        Precondition:
        - a previous call to `next_series` should have returned `True`.
        """
        ...
    
    def iter_series(self) -> SeriesIterator:
        """Get an iterator over (_metric_, _resource_, _series_) tuples.

        Warning:
            Each _series_ iterator returned in the tuple
            should first be depleted before handling the next record of this iterator.
            Out of order requests will lead to lost rows.
        """
        ...
    
    def next_series(self) -> bool:
        """Move the cursor to the next series.

        If this returns `False`, the cursor is at the end of the input.
        If this returns `True`, the `resource` and `metric` properties can be requested,
        and the available series can be iterated with `next_series`.
        """
        ...
    
    def next_row(self) -> bool:
        """Move the cursor to the next row.

        Only if this returns `true`, the `value` and `timestamp` properties can be requested.
        If it returns `false`, a call to `next_series` should be issued to check completion.

        Precondition:
        - a previous call to `next_series` should have returned `True`.
        """
        ...
    
    @property
    def resource(self) -> Optional[str]:
        """Get the _resource_ for the current cursor position.

        Precondition:
        - a previous call to `next_series` should have returned `True`.
        """
        ...
    
    @property
    def metric(self) -> Optional[str]:
        """Get the _metric_ for the current cursor position.

        Precondition:
        - a previous call to `next_series` should have returned `True`.
        """
        ...
    
    @property
    def timestamp(self) -> datetime:
        """Get the _timestamp_ for the current cursor position.

        Precondition:
        - a previous call to `next_row` should have returned `True`.
        """
        ...
    
    @property
    def value(self) -> MeasurementValue:
        """Get the _value_ for the current cursor position.

        Precondition:
        - a previous call to `next_row` should have returned `True`.
        """
        ...
    


